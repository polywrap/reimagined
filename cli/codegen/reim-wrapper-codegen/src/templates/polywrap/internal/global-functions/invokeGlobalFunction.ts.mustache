import { parse } from '@serial-as/json'
import { bufferToU32 } from "../../buffer";
import { 
  {{#globalFunctions.list}}
  {{^model.isExternal}}
  {{model.name}},
  {{/model.isExternal}}
  {{/globalFunctions.list}} 
} from "../../..";
{{#globalFunctions.relatedTypes}}
{{#isClass}}
import { {{nativeTypeNameWrapped}} } from "../../wrapped";
{{#isExternal}}
import { {{nativeTypeName}} } from "../../host/classes";
{{/isExternal}}
{{^isExternal}}
import { {{nativeTypeName}} } from "../../..";
{{/isExternal}}
{{/isClass}}
{{#isStruct}}
import { {{nativeTypeName}} } from "../../..";
{{/isStruct}}
{{/globalFunctions.relatedTypes}}
import { BaseTypeSerialization } from '../../serialization/BaseTypeSerialization';

export function invokeGlobalFunction(buffer: ArrayBuffer): ArrayBuffer {
  const funcId = bufferToU32(buffer);
  const dataBuffer = buffer.slice(4);

  switch (funcId) {
    {{#globalFunctions.list}}
    {{^model.isExternal}}
    case WrapManifest.Internal.GlobalFunction.{{model.namePascalCase}}:
        const args = {{model.namePascalCase}}ArgsWrapped.deserialize(dataBuffer);

        const result = {{model.name}}(
          {{#model.args}}
          args.{{model.name}},
          {{/model.args}}
        );

        {{#model.result.isClass}}
        return {{model.result.nativeTypeNameWrapped}}.serialize(result);
        {{/model.result.isClass}}
        {{^model.result.isClass}}
        return BaseTypeSerialization.serialize<{{model.result.nativeTypeName}}>(result);
        {{/model.result.isClass}}
    {{/model.isExternal}}
    {{/globalFunctions.list}}
    default:
      throw new Error("Unknown global function: " + funcId);
  }
}

{{#globalFunctions.list}}
{{^model.isExternal}}
export class {{model.namePascalCase}}Args {
  constructor(
    {{#model.args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
  ) {
  }
}

@serializable
class {{model.namePascalCase}}ArgsWrapped {
  constructor(
    {{#args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/args}}
  ) {
  }

  static deserialize(buffer: ArrayBuffer): {{model.namePascalCase}}Args {
    const args = parse<{{model.namePascalCase}}ArgsWrapped>(String.UTF8.decode(buffer));
  
    return new {{model.namePascalCase}}Args(
      {{#model.args}}
      {{#model.typeInfo.isClass}}
      {{model.typeInfo.nativeTypeNameWrapped}}.mapFromSerializable(args.{{model.name}}),
      {{/model.typeInfo.isClass}}
      {{^model.typeInfo.isClass}}
      args.{{model.name}},
      {{/model.typeInfo.isClass}}
      {{/model.args}}
    );
  }  
}
{{/model.isExternal}}
{{/globalFunctions.list}}
