import { parse } from "@serial-as/json";
import { {{className}} } from '../../../../../..';
{{#relatedTypes}}
{{#isClass}}
import { {{nativeTypeNameWrapped}} } from "../../../../wrapped";
{{/isClass}}
{{/relatedTypes}}
{{#relatedTypes}}
{{#isStruct}}
import { {{nativeTypeName}} } from "../../../../structs";
{{/isStruct}}
{{/relatedTypes}}
{{^result.isClass}}
import { BaseTypeSerialization } from '../../../../serialization/BaseTypeSerialization';
{{/result.isClass}}

export function {{name}}Wrapped(dataBuffer: ArrayBuffer): ArrayBuffer {
  const args = Args.deserialize(dataBuffer);

  const result = {{className}}.{{name}}(
    {{#args}}
    args.{{model.name}},
    {{/args}}
  );

  {{#result.isClass}}
  return {{result.nativeTypeNameWrapped}}.serialize(result);
  {{/result.isClass}}
  {{^result.isClass}}
  return BaseTypeSerialization.serialize<{{result.nativeTypeName}}>(result);
  {{/result.isClass}}
}

@serializable
export class Args {
  constructor(
    {{#args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/args}}
  ) {
  }

  static deserialize(buffer: ArrayBuffer): Args {
    const args = parse<SerializedArgs>(String.UTF8.decode(buffer));
  
    return new Args(
      {{#args}}
      {{#model.typeInfo.isClass}}
      {{model.typeInfo.nativeTypeNameWrapped}}.mapFromSerializable(args.{{model.name}}),
      {{/model.typeInfo.isClass}}
      {{^model.typeInfo.isClass}}
      args.{{model.name}},
      {{/model.typeInfo.isClass}}
      {{/args}}
    );
  }  
}

@serializable
class SerializedArgs {
  constructor(
    {{#args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/args}}
  ) {
  }
}
