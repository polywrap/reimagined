import { stringify } from '@serial-as/json'
import { IWrapInterface, wrapInstance } from '../../wrap/WrapInstance';
import { concat, u32ToBuffer, IWrapInstance } from '@polywrap/reim-wrap-as';
{{#relatedTypes}}
{{#isClass}}
import { {{nativeTypeNameWrapped}} } from "../../wrapped";
{{/isClass}}
{{#isStruct}}
import { {{nativeTypeName}} } from "../../..";
{{/isStruct}}
{{/relatedTypes}}
{{^result.isClass}}
import { BaseTypeSerialization } from '../../serialization/BaseTypeSerialization';
{{/result.isClass}}

export const {{name}} = (
  {{#args}}
  {{model.name}}: {{model.typeInfo.nativeTypeName}},
  {{/args}}
): {{model.result.nativeTypeName}} => {
  return {{name}}FromInstance(
    WrapModule.wrapInstance,
    {{#args}}
    {{model.name}},
    {{/args}}
  );
};

export const create = (instance: IWrapInstance) => {
  return async (
    {{#args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/args}}
  ): {{model.result.nativeTypeName}} => {
    return {{model.name}}FromInstance(
      instance, 
      {{#args}}
      {{model.name}},
      {{/args}}
    );
  };
};

export const {{name}}FromInstance = (
  instance: IWrapInterface | null, 
  {{#args}}
  {{model.name}}: {{model.typeInfo.nativeTypeName}},
  {{/args}}
): {{model.result.nativeTypeName}} => {
  if (instance == null) {
    throw new Error("connect() or import() must be called before using this module");
  }

  const args = new {{namePascalCase}}Args(
    {{#args}}
    {{model.name}},
    {{/args}}
  );

  const buffer = concat(
    u32ToBuffer(WrapManifest.External.GlobalFunction.{{namePascalCase}}),
    {{namePascalCase}}ArgsWrapped.serialize(args),
  );

  const result = instance.invokeResource(HostResource.InvokeGlobalFunction, buffer);

  {{#model.result.isClass}}
  return {{model.result.nativeTypeNameWrapped}}.serialize(result);
  {{/model.result.isClass}}
  {{^model.result.isClass}}
  return BaseTypeSerialization.serialize<{{model.result.nativeTypeName}}>(result);
  {{/model.result.isClass}}
}

@serializable
export class {{namePascalCase}}ArgsWrapped {
  constructor(
    {{#args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/args}}
  ) {
  }

  static serialize(value: {{namePascalCase}}Args): ArrayBuffer {
    return String.UTF8.encode(
      stringify<{{namePascalCase}}ArgsWrapped>(
        {{namePascalCase}}ArgsWrapped.mapToSerializable(value)
      )
    );
  }

  static mapToSerializable(value: {{namePascalCase}}Args): {{namePascalCase}}ArgsWrapped {
    return new {{namePascalCase}}ArgsWrapped(
      {{#args}}
      {{#model.isClass}}
      {{model.typeInfo.nativeTypeNameWrapped}}.mapToSerializable(value.{{model.name}}),
      {{/model.isClass}}
      {{^model.isClass}}
      value.{{model.name}},
      {{/model.isClass}}
      {{/args}}
    );
  }
}

export class {{namePascalCase}}Args {
  constructor(
    {{#args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/args}}
  ) {
  }
}
