import { wrapInstance } from '../../../wrap/WrapInstance';
import { ClassList } from '../ClassList';
import { {{name}}Method } from './{{name}}Method';
import { {{name}}Wrapped } from '../../../wrapped';
{{#relatedTypes}}
{{#isClass}}
import { {{nativeTypeNameWrapped}} } from "../../../wrapped";
{{#isExternal}}
import { {{nativeTypeName}} } from "../{{nativeTypeName}}/{{nativeTypeName}}";
{{/isExternal}}
{{^isExternal}}
import { {{nativeTypeName}} } from "../../../..";
{{/isExternal}}
{{/isClass}}
{{#isStruct}}
import { {{nativeTypeName}} } from "../../../..";
{{/isStruct}}
{{/relatedTypes}}

@serializable
export class {{name}} {
  constructor(
    private readonly __referencePtr: u32,
    {{#fields}}
    public {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/fields}}
  ) {}

  {{#methods}}
  {{#model.isStatic}}
  static {{model.name}}(
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
  ): {{model.result.nativeTypeName}} {
    const args = new {{model.namePascalCase}}ArgsWrapped( 
      {{#model.args}}
      {{model.name}},
      {{/model.args}} 
    );

    const result = wrapInstance.invokeStaticMethod<{{model.namePascalCase}}ArgsWrapped, {{model.result.nativeTypeNameWrapped}}>(
      ClassList.{{model.className}}, 
      {{model.className}}Method.{{model.namePascalCase}}, 
      args
    );

    {{#model.result.isClass}}
    return {{model.result.nativeTypeNameWrapped}}.mapFromSerializable(result);
    {{/model.result.isClass}}
    {{^model.result.isClass}}
    return result;
    {{/model.result.isClass}}
  }
  {{/model.isStatic}}
  {{^model.isStatic}}
  {{model.name}}(
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
  ): {{model.result.nativeTypeName}} {
    const args = new {{model.namePascalCase}}ArgsWrapped( 
      {{#model.args}}
      {{model.name}},
      {{/model.args}} 
    );

    const result = wrapInstance.invokeInstanceMethod<{{model.namePascalCase}}ArgsWrapped, {{model.result.nativeTypeNameWrapped}}>(
      ClassList.{{model.className}}, 
      {{model.className}}Method.{{model.namePascalCase}},
      this.__referencePtr,
      args
    );

    {{#model.result.isClass}}
    return {{model.result.nativeTypeNameWrapped}}.mapFromSerializable(result);
    {{/model.result.isClass}}
    {{^model.result.isClass}}
    return result;
    {{/model.result.isClass}}
  }
  {{/model.isStatic}}
  {{/methods}}
}

{{#methods}}
@serializable
class {{model.namePascalCase}}ArgsWrapped {
  constructor(
    {{#model.args}}
    public {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/model.args}} 
  ) {
  }
}
{{/methods}}
