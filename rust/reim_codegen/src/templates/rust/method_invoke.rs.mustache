use reim_wrap::{ ExternalWrapModule };
use module::{ WrapManifest };
{{#relatedTypes}}
{{#isClass}}
use internal::classes::{ {{nativeTypeNameWrapped}} };
{{#isExternal}}
use external::classes::{ {{nativeTypeName}} };
{{/isExternal}}
{{^isExternal}}
use crate::{ {{nativeTypeName}} };
{{/isExternal}}
{{/isClass}}
{{#isStruct}}
use crate::{ {{nativeTypeName}} };
{{/isStruct}}
{{/relatedTypes}}

pub async fn invoke(buffer: &[u8], external_module: dyn ExternalWrapModule) -> Vec<u8> {
  let func_id = u32::from_be_bytes(buffer.try_into().expect("Method ID must be 4 bytes"));
  let data_buffer = &buffer[4..];

  match func_id {
    {{#list}}
    WrapManifest::Internal::Classes::{{model.className}}Method::{{model.namePascalCase}} =>
        invoke{{model.namePascalCase}}Wrapped(data_buffer, external_module),
    {{/list}}
    _ => panic!(format!("Unknown method: {} on class {}", func_id.to_string(), model.class_name))
  }
}

{{#list}}
async fn invoke{{model.namePascalCase}}Wrapped(buffer: &[u8], external_module: dyn ExternalWrapModule) -> Vec<u8> {
    {{#model.isStatic}}
    let args = {{model.namePascalCase}}ArgsWrapped.deserialize(buffer, external_module);

    let result = {{model.className}}.{{model.name}}(
        {{#model.args}}
        args.{{model.name}},
        {{/model.args}}
    ).await;
    {{/model.isStatic}}
    {{^model.isStatic}}
    let reference_ptr = u32::from_be_bytes(buffer.try_into().expect("Reference ptr must be 4 bytes"));
    let data_buffer = &buffer[4..];

    let args = {{model.namePascalCase}}ArgsWrapped.deserialize(data_buffer, external_module);

    let object = {{model.className}}Wrapped.dereference(reference_ptr);

    let result = object.{{model.name}}(
        {{#model.args}}
        args.{{model.name}},
        {{/model.args}}
    ).await;
    {{/model.isStatic}}

    {{#model.result.isClass}}
    {{model.result.nativeTypeNameWrapped}}.serialize(result)
    {{/model.result.isClass}}
    {{^model.result.isClass}}
    BaseTypeSerialization.serialize<{{model.result.nativeTypeName}}>(result)
    {{/model.result.isClass}}
};

struct {{model.namePascalCase}}Args {
    {{#model.args}}
    pub {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
}

impl {{model.namePascalCase}}Args {
    pub fn new(
        {{#model.args}}
        {{model.name}}: {{model.typeInfo.nativeTypeName}},
        {{/model.args}}
    ) -> Self {
        Self {
            {{#model.args}}
            {{model.name}},
            {{/model.args}}
        }
    }
}

struct {{model.namePascalCase}}ArgsWrapped {
    {{#model.args}}
    pub {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/model.args}}
}

impl {{model.namePascalCase}}ArgsWrapped {
    pub fn new(
        {{#model.args}}
        {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
        {{/model.args}}
    ) {
        Self {
        {{#model.args}}
        {{model.name}},
        {{/model.args}}
        }
    }

    pub fn deserialize(buffer: Uint8Array, external_module: dyn ExternalWrapModule) -> {{model.namePascalCase}}Args {
        let args = serde_json::from_str(
            str::from_utf8(buffer).expect("Could not convert buffer to string")
        ).expect("JSON was not well-formatted");
    
        {{model.namePascalCase}}Args.new(
        {{#model.args}}
        {{#model.typeInfo.isClass}}
        {{model.typeInfo.nativeTypeNameWrapped}}.map_from_serializable(args.{{model.name}}, external_module),
        {{/model.typeInfo.isClass}}
        {{^model.typeInfo.isClass}}
        args.{{model.name}},
        {{/model.typeInfo.isClass}}
        {{/model.args}}
        )
    }  
}
{{/list}}
