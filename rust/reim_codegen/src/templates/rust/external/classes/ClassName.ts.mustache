use reim_wrap::{ ExternalModule };
use module::{ WrapManifest };
use dt::{ ExternalResource };
use external_module::{ WrapModule };
use wrapped::{ {{name}}Wrapped };
{{#relatedTypes}}
{{#isClass}}
use wrapped::{ {{nativeTypeNameWrapped}} };
{{#isExternal}}
use {{nativeTypeName}};
{{/isExternal}}
{{^isExternal}}
use crate::{{nativeTypeName}}
{{/isExternal}}
{{/isClass}}
{{#isStruct}}
use crate::{{nativeTypeName}}
{{/isStruct}}
{{/relatedTypes}}

pub fn create(instance: &dyn ExternalModule) -> {{name}}Import {
    {{name}}Import.new(instance)
}

pub struct {{name}}Import {
    instance: Box<dyn ExternalModule>,
}

impl {{name}}Import {
    pub fn new(instance: &dyn ExternalModule) -> {{name}}Import {
        {{name}}Import {
            instance: instance.clone_box(),
        }
    }

    {{#methods}}
    {{#model.isStatic}}
    pub fn async {{model.name}}(
        &self,
        {{#model.args}}
        {{model.name}}: {{model.typeInfo.nativeTypeName}},
        {{/model.args}}
    ) -> {{model.result.nativeTypeName}} {
        let args = {{model.namePascalCase}}Args.new( 
            {{#model.args}}
            {{model.name}},
            {{/model.args}} 
        );
  const funcId = 

        let buffer = [
            WrapManifest.External.Class.{{model.className}}.to_be_bytes(),
            WrapManifest.External.Classes.{{model.className}}Method.{{model.namePascalCase}}.to_be_bytes(),
            {{model.namePascalCase}}ArgsWrapped.serialize(args),
        ].concat();

        let result = self.wrapInstance.invokeResource(ExternalResource.InvokeClassMethod, buffer).await;

        {{#model.result.isClass}}
        {{model.result.nativeTypeNameWrapped}}.deserialize(result, this.wrapInstance)
        {{/model.result.isClass}}
        {{^model.result.isClass}}
        BaseTypeSerialization.deserialize<{{model.result.nativeTypeName}}>(result)
        {{/model.result.isClass}}
    }
    {{/model.isStatic}}
    {{/methods}}
}

struct {{name}} {
    __referencePtr: u32,
    __wrapInstance: ExternalModule,
    {{#fields}}
    pub {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/fields}}
}

impl {{name}} {
  {{#methods}}
  {{#model.isStatic}}
  static async {{model.name}}(
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
  ) -> {{model.result.nativeTypeName}} {
    if WrapModule.wrapInstance.is_none() {
      panic!("connect() or import() must be called before using this module");
    }

    {{model.className}}Import.new(WrapModule.wrapInstance.unwrap())
      .{{model.name}}(
        {{#model.args}}
        {{model.name}},
        {{/model.args}}
    )
  }
  {{/model.isStatic}}
  {{^model.isStatic}}
  async {{model.name}}(
    &self,
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}}
  ) -> {{model.result.nativeTypeName}} {
    if self.__wrapInstance.is_none() {
      panic!("connect() or import() must be called before using this module");
    }

    let args = {{model.namePascalCase}}Args.new( 
      {{#model.args}}
      {{model.name}},
      {{/model.args}} 
    );

    let buffer = [
      WrapManifest.External.Class.{{model.className}}.to_be_bytes(),
      WrapManifest.External.Classes.{{model.className}}Method.{{model.namePascalCase}}.to_be_bytes(),
      this.__referencePtr.to_be_bytes(),
      {{model.namePascalCase}}ArgsWrapped.serialize(args),
    ].concat();

    let result = self.__wrapInstance.invokeResource(ExternalResource.InvokeClassMethod, buffer).await;

    {{#model.result.isClass}}
    {{model.result.nativeTypeNameWrapped}}.deserialize(result, self.__wrapInstance)
    {{/model.result.isClass}}
    {{^model.result.isClass}}
    BaseTypeSerialization.deserialize<{{model.result.nativeTypeName}}>(result)
    {{/model.result.isClass}}
  }
  {{/model.isStatic}}
  {{/methods}}
}

{{#methods}}
struct {{model.namePascalCase}}Args {
    {{#model.args}}
    pub {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}} 
}

impl {{model.namePascalCase}}Args {
  static new(
    &self,
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeName}},
    {{/model.args}} 
  ) -> Self {
    {{model.namePascalCase}}Args {
      {{#model.args}}
      {{model.name}}: {{model.name}},
      {{/model.args}} 
    }
  }
}

struct {{model.namePascalCase}}ArgsWrapped {
    {{#model.args}}
    pub {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/model.args}}
}

impl {{model.namePascalCase}}ArgsWrapped {
  static new(
    &self
    {{#model.args}}
    {{model.name}}: {{model.typeInfo.nativeTypeNameWrapped}},
    {{/model.args}}
  ) -> Self {
    {{model.namePascalCase}}ArgsWrapped {
      {{#model.args}}
      {{model.name}}: {{model.name}},
      {{/model.args}}
    }
  }

  static serialize(value: {{model.namePascalCase}}Args) -> Vec<u8> {
    json!(
        {{model.namePascalCase}}ArgsWrapped.mapToSerializable(value)
    ).as_bytes()
  }

  static mapToSerializable(value: {{model.namePascalCase}}Args) -> {{model.namePascalCase}}ArgsWrapped {
    {{model.namePascalCase}}ArgsWrapped.new(
      {{#model.args}}
      {{#model.typeInfo.isClass}}
      {{model.typeInfo.nativeTypeNameWrapped}}.mapToSerializable(value.{{model.name}}),
      {{/model.typeInfo.isClass}}
      {{^model.typeInfo.isClass}}
      value.{{model.name}},
      {{/model.typeInfo.isClass}}
      {{/model.args}}
    )
  }
}
{{/methods}}
